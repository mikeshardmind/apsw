#!/usr/bin/env python3

from __future__ import annotations

import collections
import sys


def check_numbered(codepoint: int, name: str, numbered: list[tuple[str, str]]) -> bool:
    # check if codepoint are in numbered and verify name match
    # return True of codepoint covered by numbered range
    for cprange, pattern in numbered:
        start, end = [int(x, 16) for x in cprange.split("..")]
        if start <= codepoint <= end:
            expected = pattern.rsplit("-", 1)[0]
            got = name.rsplit("-", 1)[0]
            assert expected == got, f"{codepoint=:04X} {name=} {cprange=} {pattern=}"
            return True
    return False


def generate_names_code(filename: str) -> str:
    # needs DerivedName.txt source

    # these have numeric suffix, although the number
    # varies (hex of codepoint, counter) and will
    # be generated from if statement, not name tables
    numbered = [
        ("18800..18AFF", "TANGUT COMPONENT-*"),
        ("FE00..FE0F", "VARIATION SELECTOR-*"),
        # unicode 16
        ("E0100..E01EF", "VARIATION SELECTOR-*"),
    ]

    # codepoint to name
    mapping: dict[int, str] = {}

    # parse data
    print("Reading", filename)
    for line in open(filename, "rt"):
        if not line.lstrip() or line.startswith("#"):
            continue

        codepoint, name = (p.strip() for p in line.split(";"))

        if name.endswith("-*"):
            # 18cff in unicode 16.0
            if ".." not in codepoint:
                codepoint = f"{codepoint}..{codepoint}"
            numbered.append((codepoint, name))
            continue

        cpint = int(codepoint, 16)

        if check_numbered(cpint, name, numbered):
            continue

        # hangul syllable
        if 0xAC00 <= cpint <= 0xD7A3:
            continue

        mapping[cpint] = name

    # only 38 different chars are used for names.  we find substrings to use
    # with the other bytes
    letters = set()
    for name in mapping.values():
        letters.update(name)
    assert len(letters) == 38, f"{sorted(letters)=} {len(letters)=}"

    # substitutions - byte to substring
    subs: dict[str, str | None] = {}

    for i in range(0, 256):
        subs[chr(i)] = chr(i) if chr(i) in letters else None

    # \0 doesn't occur in text
    original_text = "\0".join(mapping.values())

    # the order substitutions are applied because they can incorporate each other
    subs_order: list[str] = []

    while any(v is None for v in subs.values()):
        text = original_text

        for s in subs_order:
            text = text.replace(subs[s], s)

        substrings: collections.Counter[str] = collections.Counter()

        for s in text.split("\0"):
            for n in range(2, len(s) + 1):
                for pos in range(0, len(s) - n + 1):
                    substrings[s[pos : pos + n]] += 1

        best_savings, best_substring = -1, ""

        for substring, count in substrings.most_common():
            # can it possibly improve?
            if len(substring) * count < best_savings:
                continue
            savings = len(text) - len(text.replace(substring, " "))
            # we want better savings, or equal savings with longer fragment
            if savings > best_savings or (savings == best_savings and len(substring) > len(best_substring)):
                best_savings = savings
                best_substring = substring

        count = text.count(best_substring)
        print(
            f"{best_savings=} {best_substring=} {count=}  remaining slots =",
            len(subs) - sum((0 if v is None else 1) for v in subs.values()),
        )
        for s in subs:
            if subs[s] is None:
                subs[s] = best_substring
                subs_order.append(s)
                break
        else:
            raise Exception("unreachable")

        text = original_text
        for s in subs_order:
            text = text.replace(subs[s], s)

    print(f"original size = {len(original_text):,}   substring replaced = {len(text):,}")

    code: list[str] = []
    code.append("/* This file is automatically generated from DerivedName.txt - do not edit */")
    code.append("")

    code.append("/* This array is 256 entries long where each entry is")
    code.append("   a byte indicating length and then the replacement text */")
    code.append("static const char * const name_subs[] = {")

    for text in subs.values():
        for s in reversed(subs_order):
            text = text.replace(s, subs[s])
        code.append(f'  "\\x{len(text):02x}" "{text}",')

    code.append("};")

    code.append("")
    code.append("")

    tag_range_start = 0xE0001
    tag_range_end = 0xE007F
    table = [mapping.pop(codepoint, "") for codepoint in range(tag_range_start, tag_range_end + 1)]
    code.append("/* name mapping for inline tags which appear near the end of the range */")
    code.append(f"#define TAG_RANGE_START 0x{tag_range_start:X}")
    code.append(f"#define TAG_RANGE_END   0x{tag_range_end:X}")
    code.append("")
    code.append("static const unsigned char *tag_range_names[] = {")
    for text in table:
        code.append("    (const unsigned char[]){")
        for s in subs_order:
            text = text.replace(subs[s], s)
        text = chr(len(text)) + text
        for c in text:
            code[-1] += f" {ord(c)},"
        code[-1] += " },"
    code.append("};")

    code.append("")
    code.append("")

    code.append("/* This handles the numbered suffix ranges */")
    code2: list[str] = []
    code2.append("#define NAME_RANGES(codepoint)")
    # ranges where it is hex of the codepoint (most of them)
    hex_id = ("%04X", "")
    for cprange, pattern in sorted(numbered, key=lambda x: int(x[0].split("..")[0], 16)):
        number_format, adjust = {
            "3400..4DBF": hex_id,
            "4E00..9FFF": hex_id,
            "F900..FA6D": hex_id,
            "FA70..FAD9": hex_id,
            "FE00..FE0F": ("%d", " - 0xFE00 + 1"),
            "13460..143FA": hex_id,
            "17000..187F7": hex_id,
            "18800..18AFF": ("%03d", " - 0x18800 + 1"),
            "18B00..18CD5": hex_id,
            "18CFF..18CFF": hex_id,
            "18D00..18D08": hex_id,
            "1B170..1B2FB": hex_id,
            "20000..2A6DF": hex_id,
            "2A700..2B739": hex_id,
            "2B740..2B81D": hex_id,
            "2B820..2CEA1": hex_id,
            "2CEB0..2EBE0": hex_id,
            "2EBF0..2EE5D": hex_id,
            "2F800..2FA1D": hex_id,
            "30000..3134A": hex_id,
            "31350..323AF": hex_id,
            "E0100..E01EF": ("%d", " - 0xE0100 + 17"),
        }[cprange]
        start, end = [int(x, 16) for x in cprange.split("..")]
        code2.append(f"  if(codepoint >= 0x{start:04X} && codepoint <= 0x{end:04X})")
        assert pattern.endswith("-*")
        code2.append(f'    return PyUnicode_FromFormat("{pattern[:-1]}{number_format}", codepoint{adjust});')

    max_len = max(len(c) for c in code2) + 1
    for c in code2[:-1]:
        code.append(c + " " * (max_len - len(c)) + "\\")
    code.append(code2[-1])
    code.append("")

    max_cp_with_name = max(mapping)
    assert max_cp_with_name < 0xE0001
    code.append("/* The maximum value for which there is a codepoint name (excluding named ranges) */")
    code.append(f"#define MAX_CODEPOINT_WITH_NAME 0x{max_cp_with_name:X}")

    return "\n".join(code) + "\n"


c = generate_names_code(sys.argv[1])

open("dbnames.h", "wt").write(c)
